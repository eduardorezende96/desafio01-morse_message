# Morse-message
receiving messages and translating them to or from morse

## Por que Rabbitmq?
  A ideia é uma solução escalável que recebe um código morse e traduz para texto, ou recebe um texto e traduz para código morse. Rabbitmq foi escolhido como framework por ser um dos framework que melhor serve nesse caso. Entre os principais pontos positivos, podem ser destacados a implantação distribuída (distributed deployment), administração e monitoramento, tolerância a falhas, eficiência e facilidade de integração. O rabbitmq é um dos corretores de mensagens (message broker) mais populares da atualidade, justamente por permitir ao desenvolvedor a criar e implementar algo que sirva muito bem a diversas situações. O rabbitmq utiliza o protocolo de mensagens AMQP, que utiliza exchanges como intermediárias para transmitir a

## Por que direct?
  O rabbitmq utiliza o protocolo de mensagens AMQP, que utiliza exchanges como intermediárias para transmitir as mensagens. Existem quatro tipos de exchange e a que foi implementada nesse código foi a do tipo direct. Esse tipo foi escolhido por vários motivos. O primeiro deles é a necessidade de uma chave, algo parecido com uma senha, para acessar a mensagem. Caso o receptor queira receber determinada mensagem, ele vai precisar saber por qual chave essa mensagem foi enviada. Outra vantagem que o direct permite, é receber apenas algumas mensagens, permitir que os usuários utilizem de determinado código (decidido entre os próprios usuários), para decidir diversos assuntos, como por exemplo, qual a importância, ou a urgência, de determinado assunto, além de permitir que essa mensagem seja acessada por diversas fontes diferentes. Dessa forma, isso permitiria que apenas quem soubesse da chave conseguisse acessar determinada mensagem, e consequentemente traduzi-la. Aliado ao AMQP, isso também diminuiria as chances de perder a mensagem.
  
## Sobre a entrada
  Para o código funcionar corretamente, basta que o usuário (com python e rabbitmq instalado) rode primeiramente o código receive_logs_direct.py, com a(s) respectiva(s) chave(s), por exemplo, "py receive_logs_direct.py random_key1 random_key2 e depois mandar as mensagens ao rodar o código emit_logs_direct, seguido pela chave pela qual a mensagem deve ser enviada, e, por último, a mensagem a ser enviada, entre aspas (por exemplo, py emit_logs_direct random_key1 "mensagem um"). Caso a mensagem seja enviada sem aspas, o código ainda funcionará, e a mensagem será traduzida, mas poderá haver um erro de tradução de morse para texto, pois caso a entrada possua um espaço duplo, esse espaço seria simplicado para um espaço único, o que resultaria em uma tradução para texto sem espaço, como se a mensagem enviada fosse uma palavra só.
  
 ## Quanto à tradução
  Ao enviar a mensagem para o receptor, o receptor irá enviar essa mensagem para um tradutor. Ao enviar essa tradução, a primeira coisa que será feita pelo código é identificar que tipo de mensagem está sendo recebida. Para isso, será contado a quantidade de pontos ("."), hífens ("-") e espaços (" "), que são os únicos caracteres aceitos em um código morse. essas quantidades serão somadas, e será considerado código morse caso essa soma seja igual à quantidade de caracteres (contando os espaços) da mensagem/string. Identificando o tipo de mensagem, será chamada a respectiva função de tradução, que irá ser traduzida de letra por letra. No caso da tradução de txt para morse, simplesmente foi traduzido de letra por letra através de um laço de repetição que percorria a mensagem original, não traduzida, "substituindo" as letras originais por letras em código morse (está entre aspas porque não é realmente substituído, mas sim criada outra variável, que salva essa mensagem traduzida. Já quanto ao processo inverso, de tradução de morse para txt, foi um processo um pouco mais complexo. Isso porque ao separar a string da forma normal (com split), todos os espaços, únicos ou duplos, não são salvos, e a tradução seria feita sem espaços. Por isso, foi necessário usar um outro recurso, chamado de re.split, para que os espaços duplos ficassem salvos de alguma forma na lista, perimitindo que o texto fosse traduzido da forma correta. Porém, ao iniciar o emissor da mensagem sem as aspas, o emissor sequer recebe a mensagem com dois espaços, fazendo com que a mensagem seja traduzida sem espaço nenhum.
  
  ## Evolução do produto
  A primeira coisa a ser feita no produto, é mudar a forma como as letras são identificadas e traduzidas. Atualmente, existe um dicionário com uma quantidade maior do que o adequado. Considerando que isso está em um arquivo separado e, só tem isso, não é muito difícil de entender, mas seria melhor se a quantidade de ifs fosse reduzida. Outro detalhe que poderia ser implementado, é uma autenticação de chave, para que isso funcione como uma espécie de login e senha, tornando o envia e recebimento das mensagens mais seguros, evitando que outras pessoas visualizem determinada mensagem que não deveriam ver.
